<!DOCTYPE html>
<html lang="en">
    <!-- title -->




<!-- keywords -->




<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" >
    <meta name="author" content="Huang Yangyi">
    <meta name="renderer" content="webkit">
    <meta name="copyright" content="Huang Yangyi">
    
    <meta name="keywords" content="hexo,hexo-blog">
    
    <meta name="description" content="An underguaduate student of ZJU, majoring in CS">
    <meta http-equiv="Cache-control" content="no-cache">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"/>
    <title>计算机视觉 期末速成笔记 · huangyangyi&#39;s Blog</title>
    <style type="text/css">
    @font-face {
        font-family: 'Oswald-Regular';
        src: url("/font/Oswald-Regular.ttf");
    }

    body {
        margin: 0;
    }

    header,
    footer,
    .back-top,
    .sidebar,
    .container,
    .site-intro-meta,
    .toc-wrapper {
        display: none;
    }

    .site-intro {
        position: relative;
        z-index: 3;
        width: 100%;
        /* height: 50vh; */
        overflow: hidden;
    }

    .site-intro-placeholder {
        position: absolute;
        z-index: -2;
        top: 0;
        left: 0;
        width: calc(100% + 300px);
        height: 100%;
        background: repeating-linear-gradient(-45deg, #444 0, #444 80px, #333 80px, #333 160px);
        background-position: center center;
        transform: translate3d(-226px, 0, 0);
        animation: gradient-move 2.5s ease-out 0s infinite;
    }

    @keyframes gradient-move {
        0% {
            transform: translate3d(-226px, 0, 0);
        }
        100% {
            transform: translate3d(0, 0, 0);
        }
    }

</style>

    <link rel="preload" href= "/css/style.css?v=20180824" as="style" onload="this.onload=null;this.rel='stylesheet'" />
    <link rel="stylesheet" href= "/css/mobile.css?v=20180824" media="(max-width: 980px)">
    
    <link rel="preload" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'" />
    
    <!-- /*! loadCSS. [c]2017 Filament Group, Inc. MIT License */
/* This file is meant as a standalone workflow for
- testing support for link[rel=preload]
- enabling async CSS loading in browsers that do not support rel=preload
- applying rel preload css once loaded, whether supported or not.
*/ -->
<script>
(function( w ){
	"use strict";
	// rel=preload support test
	if( !w.loadCSS ){
		w.loadCSS = function(){};
	}
	// define on the loadCSS obj
	var rp = loadCSS.relpreload = {};
	// rel=preload feature support test
	// runs once and returns a function for compat purposes
	rp.support = (function(){
		var ret;
		try {
			ret = w.document.createElement( "link" ).relList.supports( "preload" );
		} catch (e) {
			ret = false;
		}
		return function(){
			return ret;
		};
	})();

	// if preload isn't supported, get an asynchronous load by using a non-matching media attribute
	// then change that media back to its intended value on load
	rp.bindMediaToggle = function( link ){
		// remember existing media attr for ultimate state, or default to 'all'
		var finalMedia = link.media || "all";

		function enableStylesheet(){
			link.media = finalMedia;
		}

		// bind load handlers to enable media
		if( link.addEventListener ){
			link.addEventListener( "load", enableStylesheet );
		} else if( link.attachEvent ){
			link.attachEvent( "onload", enableStylesheet );
		}

		// Set rel and non-applicable media type to start an async request
		// note: timeout allows this to happen async to let rendering continue in IE
		setTimeout(function(){
			link.rel = "stylesheet";
			link.media = "only x";
		});
		// also enable media after 3 seconds,
		// which will catch very old browsers (android 2.x, old firefox) that don't support onload on link
		setTimeout( enableStylesheet, 3000 );
	};

	// loop through link elements in DOM
	rp.poly = function(){
		// double check this to prevent external calls from running
		if( rp.support() ){
			return;
		}
		var links = w.document.getElementsByTagName( "link" );
		for( var i = 0; i < links.length; i++ ){
			var link = links[ i ];
			// qualify links to those with rel=preload and as=style attrs
			if( link.rel === "preload" && link.getAttribute( "as" ) === "style" && !link.getAttribute( "data-loadcss" ) ){
				// prevent rerunning on link
				link.setAttribute( "data-loadcss", true );
				// bind listeners to toggle media back
				rp.bindMediaToggle( link );
			}
		}
	};

	// if unsupported, run the polyfill
	if( !rp.support() ){
		// run once at least
		rp.poly();

		// rerun poly on an interval until onload
		var run = w.setInterval( rp.poly, 500 );
		if( w.addEventListener ){
			w.addEventListener( "load", function(){
				rp.poly();
				w.clearInterval( run );
			} );
		} else if( w.attachEvent ){
			w.attachEvent( "onload", function(){
				rp.poly();
				w.clearInterval( run );
			} );
		}
	}


	// commonjs
	if( typeof exports !== "undefined" ){
		exports.loadCSS = loadCSS;
	}
	else {
		w.loadCSS = loadCSS;
	}
}( typeof global !== "undefined" ? global : this ) );
</script>

    <link rel="icon" href= "/assets/favicon-hyy.ico" />
    <link rel="preload" href="https://cdn.jsdelivr.net/npm/webfontloader@1.6.28/webfontloader.min.js" as="script" />
    <link rel="preload" href="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js" as="script" />
    <link rel="preload" href="/scripts/main.js" as="script" />
    <link rel="preload" as="font" href="/font/Oswald-Regular.ttf" crossorigin>
    <link rel="preload" as="font" href="https://at.alicdn.com/t/font_327081_1dta1rlogw17zaor.woff" crossorigin>
    
    <!-- fancybox -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.js" defer></script>
    <!-- 百度统计  -->
    
    <!-- 谷歌统计  -->
    
<meta name="generator" content="Hexo 4.2.0"></head>

    
        <body class="post-body">
    
    
<header class="header">

    <div class="read-progress"></div>
    <div class="header-sidebar-menu">&#xe775;</div>
    <!-- post页的toggle banner  -->
    
    <div class="banner">
            <div class="blog-title">
                <a href="/" >huangyangyi&#39;s Blog.</a>
            </div>
            <div class="post-title">
                <a href="#" class="post-name">计算机视觉 期末速成笔记</a>
            </div>
    </div>
    
    <a class="home-link" href=/>huangyangyi's Blog.</a>
</header>
    <div class="wrapper">
        <div class="site-intro" style="







height:50vh;
">
    
    <!-- 主页  -->
    
    
    <!-- 404页  -->
            
    <div class="site-intro-placeholder"></div>
    <div class="site-intro-img" style="background-image: url(/intro/post-bg.jpg)"></div>
    <div class="site-intro-meta">
        <!-- 标题  -->
        <h1 class="intro-title">
            <!-- 主页  -->
            
            计算机视觉 期末速成笔记
            <!-- 404 -->
            
        </h1>
        <!-- 副标题 -->
        <p class="intro-subtitle">
            <!-- 主页副标题  -->
            
            
            <!-- 404 -->
            
        </p>
        <!-- 文章页meta -->
        
            <div class="post-intros">
                <!-- 文章页标签  -->
                
                    <div class= post-intro-tags >
    
        <a class="post-tag" href="javascript:void(0);" data-tags = "Computer Vision">Computer Vision</a>
    
</div>
                
                
                    <div class="post-intro-read">
                        <span>Word count: <span class="post-count word-count">3k</span>Reading time: <span class="post-count reading-time">12 min</span></span>
                    </div>
                
                <div class="post-intro-meta">
                    <span class="post-intro-calander iconfont-archer">&#xe676;</span>
                    <span class="post-intro-time">2020/01/13</span>
                    
                    <span id="busuanzi_container_page_pv" class="busuanzi-pv">
                        <span class="iconfont-archer">&#xe602;</span>
                        <span id="busuanzi_value_page_pv"></span>
                    </span>
                    
                    <span class="shareWrapper">
                        <span class="iconfont-archer shareIcon">&#xe71d;</span>
                        <span class="shareText">Share</span>
                        <ul class="shareList">
                            <li class="iconfont-archer share-qr" data-type="qr">&#xe75b;
                                <div class="share-qrcode"></div>
                            </li>
                            <li class="iconfont-archer" data-type="weibo">&#xe619;</li>
                            <li class="iconfont-archer" data-type="qzone">&#xe62e;</li>
                            <li class="iconfont-archer" data-type="twitter">&#xe634;</li>
                            <li class="iconfont-archer" data-type="facebook">&#xe67a;</li>
                        </ul>
                    </span>
                </div>
            </div>
        
    </div>
</div>
        <script>
 
  // get user agent
  var browser = {
    versions: function () {
      var u = window.navigator.userAgent;
      return {
        userAgent: u,
        trident: u.indexOf('Trident') > -1, //IE内核
        presto: u.indexOf('Presto') > -1, //opera内核
        webKit: u.indexOf('AppleWebKit') > -1, //苹果、谷歌内核
        gecko: u.indexOf('Gecko') > -1 && u.indexOf('KHTML') == -1, //火狐内核
        mobile: !!u.match(/AppleWebKit.*Mobile.*/), //是否为移动终端
        ios: !!u.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/), //ios终端
        android: u.indexOf('Android') > -1 || u.indexOf('Linux') > -1, //android终端或者uc浏览器
        iPhone: u.indexOf('iPhone') > -1 || u.indexOf('Mac') > -1, //是否为iPhone或者安卓QQ浏览器
        iPad: u.indexOf('iPad') > -1, //是否为iPad
        webApp: u.indexOf('Safari') == -1, //是否为web应用程序，没有头部与底部
        weixin: u.indexOf('MicroMessenger') == -1, //是否为微信浏览器
        uc: u.indexOf('UCBrowser') > -1 //是否为android下的UC浏览器
      };
    }()
  }
  console.log("userAgent:" + browser.versions.userAgent);

  // callback
  function fontLoaded() {
    console.log('font loaded');
    if (document.getElementsByClassName('site-intro-meta')) {
      document.getElementsByClassName('intro-title')[0].classList.add('intro-fade-in');
      document.getElementsByClassName('intro-subtitle')[0].classList.add('intro-fade-in');
      var postIntros = document.getElementsByClassName('post-intros')[0]
      if (postIntros) {
        postIntros.classList.add('post-fade-in');
      }
    }
  }

  // UC不支持跨域，所以直接显示
  function asyncCb(){
    if (browser.versions.uc) {
      console.log("UCBrowser");
      fontLoaded();
    } else {
      WebFont.load({
        custom: {
          families: ['Oswald-Regular']
        },
        loading: function () {  //所有字体开始加载
          // console.log('loading');
        },
        active: function () {  //所有字体已渲染
          fontLoaded();
        },
        inactive: function () { //字体预加载失败，无效字体或浏览器不支持加载
          console.log('inactive: timeout');
          fontLoaded();
        },
        timeout: 5000 // Set the timeout to two seconds
      });
    }
  }

  function asyncErr(){
    console.warn('script load from CDN failed, will load local script')
  }

  // load webfont-loader async, and add callback function
  function async(u, cb, err) {
    var d = document, t = 'script',
      o = d.createElement(t),
      s = d.getElementsByTagName(t)[0];
    o.src = u;
    if (cb) { o.addEventListener('load', function (e) { cb(null, e); }, false); }
    if (err) { o.addEventListener('error', function (e) { err(null, e); }, false); }
    s.parentNode.insertBefore(o, s);
  }

  var asyncLoadWithFallBack = function(arr, success, reject) {
      var currReject = function(){
        reject()
        arr.shift()
        if(arr.length)
          async(arr[0], success, currReject)
        }

      async(arr[0], success, currReject)
  }

  asyncLoadWithFallBack([
    "https://cdn.jsdelivr.net/npm/webfontloader@1.6.28/webfontloader.min.js", 
    "https://cdn.bootcss.com/webfont/1.6.28/webfontloader.js",
    "/lib/webfontloader.min.js"
  ], asyncCb, asyncErr)
</script>        
        <img class="loading" src="/assets/loading.svg" style="display: block; margin: 6rem auto 0 auto; width: 6rem; height: 6rem;" />
        <div class="container container-unloaded">
            <main class="main post-page">
    <article class="article-entry">
        <blockquote>
<p>内容主要是Liming Song老师的计算机视觉课程的考试内容, 所以题目也叫期末速成笔记, 并不能很好地覆盖课程的全部内容, 仅供参考.</p>
</blockquote>
<h1 id="计算机视觉要解决的任务"><a href="#计算机视觉要解决的任务" class="headerlink" title="计算机视觉要解决的任务"></a>计算机视觉要解决的任务</h1><ol>
<li><p>中心任务就是对图像进行理解</p>
<ol>
<li>对单幅图像、多幅图像、视频图像的理解</li>
<li>几个核心问题：分割问题、识别问题、三维重构问题、运动分割与跟踪问题</li>
</ol>
</li>
<li><p>五大研究内容：输入设备、低层视觉、中层视觉、高层视觉、体系结构</p>
</li>
<li>基本任务: <ul>
<li>图片和视频的分类</li>
<li>检测和定位物体, 图片分割</li>
<li>估计语义和集合属性</li>
<li>对人类活动和事件进行分类</li>
</ul>
</li>
<li>挑战因素: 视角变化, 光线变化, 尺度变化, 物体形变, 物体遮挡, 背景凌乱, 内部类别多样</li>
</ol>
<h1 id="Marr视觉计算理论"><a href="#Marr视觉计算理论" class="headerlink" title="Marr视觉计算理论"></a>Marr视觉计算理论</h1><ol>
<li>信息处理分析的三个层次<ol>
<li>计算理论层：目的？为什么合适？执行策略？<strong>需要使用何种类型的约束来完成这一过程</strong> 马尔认为合理的约束是场景固有的性质在成像过程中对图像形成的约束 </li>
<li>表示和算法层：如何实现？输入输出的表示？标识和表示之间的变换？</li>
<li>实现层：物理上如何实现这些表示和算法？</li>
</ol>
</li>
<li>视觉表示框架三个阶段<ol>
<li>将输入的原始图像进行处理，抽取基本特征形成基元图</li>
<li>在以观测者为中心的坐标系中，由输入图像和基元图回复场景可见部分的深度、法线方向、轮廓等形成二维半图</li>
<li>后期阶段：以物体为中心的坐标系中，由输入图像、基元图和二维半图来恢复、表示和识别三维物体</li>
</ol>
</li>
</ol>
<h1 id="格式塔心理学"><a href="#格式塔心理学" class="headerlink" title="格式塔心理学"></a>格式塔心理学</h1><ul>
<li>相近性原理：距离近的物理总是容易被认为成一个整体</li>
<li>相似性原理：形状大小颜色等等物理属性相似时，就容易被认为成一个整体</li>
<li>连续性原理：视觉倾向于感知连续的形式而不是离散的碎片</li>
<li>封闭性原理：视觉系统自动尝试将敞开的图形关闭起来，从而将其感知为完整的物体而不是分散的碎片</li>
<li>优美形态法则：对称、简洁、规则的图形，尽可能组成好的图形。</li>
<li>图形与背景法则：大脑将视觉区域分为主体和背景，主体包括一个场景中占据我们主要注意力的所有元素，其余则是背景</li>
</ul>
<h1 id="二值图像"><a href="#二值图像" class="headerlink" title="二值图像"></a>二值图像</h1><ul>
<li>把灰度图像二值化，变为0/255或1/0（前景/背景）</li>
<li>Otsu大津算法：通过直方图得到阈值, 最大化类间方差</li>
<li>几何特性：尺寸和位置 (只要求说出有哪几种)<ul>
<li>尺寸<ul>
<li>面积<script type="math/tex">A=\sum_{i=0}^{n-1} \sum_{j=0}^{m-1}B[i,j]</script></li>
<li>区域中心 <script type="math/tex">\bar x = \frac{A=\sum_{i=0}^{n-1}\sum_{j=0}^{m-1}jB[i,j]}{A} \\ \bar y = \frac{A=\sum_{i=0}^{n-1}\sum_{j=0}^{m-1}iB[i,j]}{A}</script></li>
</ul>
</li>
<li>方向<ul>
<li>某些形状没有方向；假定物体是长的，长轴方向为物体方向</li>
<li>将求方向转换为最小化<script type="math/tex">\chi ^2=\sum_{i=0}^{n-1}\sum_{j=0}^{m-1}r_{ij}^2B[i,j]</script>, <script type="math/tex">r_{ij}</script>为点<script type="math/tex">[i,j]</script>到直线的距离</li>
<li>用最小二乘法拟合求解<ul>
<li>将直线方程表示为<script type="math/tex">\rho=x\cos\theta + y\sin\theta</script>, 那么到直线的距离为<script type="math/tex">r^2=(x\cos\theta+y\sin\theta-\rho)</script></li>
<li>最小化<script type="math/tex">\chi^2=\sum_{i=0}^{n-1}\sum_{j=0}^{m-1}(x_{ij}\cos\theta+y_{ij}\sin\theta-\rho)^2B[i,j]</script>, 得<script type="math/tex">\rho = \bar x\cos\theta + \bar y\sin\theta</script>, 则<script type="math/tex">\chi ^2=a\cos^2\theta+b\sin\theta\cos\theta+c\sin^2\theta</script></li>
<li>说明回归直线过物体中心，代入，继续微分求解<script type="math/tex">\theta</script>即可<script type="math/tex; mode=display">\chi^2=a\cos^2\theta+b\sin\theta\cos\theta+c\sin^2\theta\\\sin2\theta=\pm\frac{b}{\sqrt{b^2+(a-c)^2}}\\\cos2\theta=\pm\frac{a-c}{\sqrt{b^2+(a-c)^2}}</script></li>
</ul>
</li>
</ul>
</li>
<li>伸长率：<script type="math/tex">E=\frac{\chi_{max}}{\chi_{min}}</script></li>
<li>密集度：<script type="math/tex">C=\frac{A}{p^2}</script>, 周长相同，密集度越高面积越大</li>
<li>形态比:最小外接矩形长宽比</li>
<li>欧拉数:连通分量数减去洞数<script type="math/tex">E=C-H</script></li>
<li>距离度量<ul>
<li>首先距离要符合对称性, 自反性, 三角不等式</li>
<li>欧几里得距离</li>
<li>街区距离(City Block distance)即曼哈顿距离,<script type="math/tex">d_{12}=|x_1-x_2|+|y_1-y_2|</script></li>
<li>棋盘距离即Chebyshev Distance, <script type="math/tex">d_{12}=\max(|x_1-x_2|, |y_1-y_2|)</script></li>
<li>Minkowski距离(<script type="math/tex">p</script>-norm distance): <script type="math/tex">L_p=\sqrt[p]{\sum_{k=1}^{n}|x_{1k}-x_{2k}|^p}</script></li>
</ul>
</li>
</ul>
</li>
<li>投影计算(要求知道定义和基本原理, 给例子会计算)<ul>
<li>给定一条直线,用垂直于该直线的一簇等间距直线将一副二值图像分割成若干条,每一条内像素值为1的像素数量<ul>
<li>垂直投影是对每一<strong>横行</strong>统计, 水平投影是对每一<strong>竖列</strong>统计</li>
</ul>
</li>
<li>对角线投影, 标号为d的对角线: <script type="math/tex">d=ai+bj+c</script>, 下面给出一种编号方式:<script type="math/tex; mode=display">a\cdot 0 +b(m-1)+c=1\\a(n-1)+b\cdot 0 +c=n+m-1\\a=-b\\\Rightarrow d=i-j+m(m是长边)</script></li>
</ul>
</li>
<li>连通区域<ul>
<li>四连通, 八连通的邻点概念</li>
<li>连通分量标记算法(贯序)(以四连通为例)<ul>
<li>从左到右从上到下扫描</li>
<li>分析上邻点标记<script type="math/tex">x</script>与左邻点标记<script type="math/tex">y</script><ul>
<li><script type="math/tex">x, y</script>只有一个存在或<script type="math/tex">x=y</script>, 复制这一标记</li>
<li><script type="math/tex">x\neq y</script>复制上邻点标记<script type="math/tex">x</script>, 在等价表中记<script type="math/tex">x, y</script>两个标记为等价</li>
<li>都无标记, 分配新标记<script type="math/tex">z</script>, 将<script type="math/tex">z</script>记入等价表</li>
</ul>
</li>
</ul>
</li>
<li>区域边界跟踪算法(8邻点)(可能会出具体例子的计算)<ul>
<li>从左到右从上到下找区域S起始点<script type="math/tex">s(k)=(x(k), y(k)),k=0</script></li>
<li>用<script type="math/tex">c</script>表示跟踪的边界点, 令<script type="math/tex">c=s(k)</script>, 其左邻点为<script type="math/tex">b, b\in\bar S</script></li>
<li>从<script type="math/tex">b</script>开始逆时针地找<script type="math/tex">c</script>的8邻点<script type="math/tex">n_1,...,n_8</script>, 把第一个<script type="math/tex">n_i\in S</script>作为<script type="math/tex">s(k+1)</script></li>
<li>选择下一个<script type="math/tex">b, c</script>, 重复直到<script type="math/tex">s(k)=s(0)</script></li>
<li>可以加平滑</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="边缘检测"><a href="#边缘检测" class="headerlink" title="边缘检测"></a>边缘检测</h1><ul>
<li>卷积与模板: <script type="math/tex">T * I(X,Y)=\sum_{i=0}^{n-1}\sum_{j=0}^{m-1}T(i,j)I(X+i,Y+j)</script></li>
<li>origin of edges 四种最主要的不连续(discontinuity)<br><img src="Clipboard_2020-01-12-20-39-37.png" alt=""></li>
<li>边缘检测基本思想<ul>
<li>函数导数反应图像灰度变化的显著程度</li>
<li>一阶导数的局部最大值, 或者二阶导数的过零点</li>
</ul>
</li>
<li>一阶边缘检测(有哪些)<ul>
<li>用差分近似偏导数<script type="math/tex">G_x=f[x+1, y]-f[x,y],\ G_y=f[x, y]-f[x, y+1]</script></li>
<li>梯度方向<script type="math/tex">a(x,y)=arctan(G_y/G_x)</script></li>
<li>Roberts交叉算子 <script type="math/tex">G[i, j]=|f[i,j]-f[i+1, j+1]|+|f[i+1,j|-f[i,j+1]|</script><br><img src="Clipboard_2020-01-12-20-58-05.png" alt=""></li>
<li>Sobel算子<br><img src="Clipboard_2020-01-12-20-59-41.png" alt=""></li>
<li>Prewitt算子, 运算较快<br><img src="Clipboard_2020-01-12-21-00-17.png" alt=""></li>
</ul>
</li>
<li>二阶边缘检测(有哪些)<ul>
<li><strong>Laplacian算子</strong><script type="math/tex; mode=display">G_{xx}=(f[i,j+1]-f[i,j])-(f[i,j]-f[i,j-1])\\G_{yy}=(f[i+1,j]-2f[i,j])+f[i-1,j]</script><ul>
<li>卷积模板<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0  1  0     1  4  1</span><br><span class="line">1 -4  1     4 -20 4</span><br><span class="line">0  1  0     1  4  1</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><strong>LoG算子(Marr&amp;Hildreth算子)</strong> <ul>
<li>Laplacian of Gaussian<script type="math/tex; mode=display">h(x,y)=\nabla^2[g(x,y)*f(x,y)]或\\h(x,y)=[\nabla^2g(x,y)]*f(x,y)\\其中g(x,y)为高斯函数</script></li>
<li>即图像与Gaussian函数卷积, 再求卷积Laplacian微分</li>
<li>或者求Gaussian函数的Laplacian微分,再与图像卷积</li>
<li><strong>为什么要加G?</strong><br>使用高斯滤波器进行降噪处理, 提高对噪声和离散点的鲁棒性</li>
</ul>
</li>
<li><strong>Canny边缘检测</strong><ul>
<li>步骤<ol>
<li>用高斯滤波器平滑图像<script type="math/tex; mode=display">S[i,j]=G[i,j:\sigma]*I[i,j]</script></li>
<li>用一阶有限差分计算偏导, 然后计算梯度幅值和方向<script type="math/tex; mode=display">G_x[i,j]\approx(S[i,j+1]-S[i,j]+S[i+1,j+1]-S[i+1,j])/2</script><script type="math/tex; mode=display">G_y[i,j]\approx(S[i,j]-S[i+1,j]+S[i,j+1]-S[i+1,j+1])/2</script><script type="math/tex; mode=display">梯度幅值M[i,j]=\sqrt{G_x[i,j]^2+G_y[i,j]^2}</script><script type="math/tex; mode=display">方向角\theta=\arctan(G_y[i,j]/G_x[i,j])</script></li>
<li>对梯度幅值进行NMS非极大值抑制<ul>
<li>去掉幅值局部变化非极大的点</li>
<li>将梯度角离散化为圆周的四个方向, 如果<script type="math/tex">M[i,j]</script>不大于在<script type="math/tex">\theta[i,j]</script>所在的离散方向<script type="math/tex">\zeta[i,j]</script>的两个相邻点的幅值, 那么抑制<script type="math/tex">N[i,j]=0</script></li>
</ul>
</li>
<li>用双阈值算法检测和连接边缘<ol>
<li>取高低两个阈值<script type="math/tex">T_2, T_1(T_2\approx T_1 *(2 或 3))</script>作用于新幅值图<script type="math/tex">N[i,j]</script>, 得到高阈值边缘和低阈值边缘图</li>
<li>连接高阈值边缘图, 出现断点时, 在低阈值边缘图中8邻点域搜寻边缘点<br><strong>阈值的含义</strong>:<br>因为阈值太低会导致假边缘, 太高会导致部分轮廓丢失; 采用双阈值的方案, 首先使用高阈值边缘图为基础避免假边缘, 然后用低阈值边缘图来补全丢失的轮廓</li>
</ol>
</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="曲线"><a href="#曲线" class="headerlink" title="曲线"></a>曲线</h1><ul>
<li>链码: 用相邻边缘点组成的方向序列来表示边缘<br><img src="Clipboard_2020-01-12-22-28-20.png" alt=""></li>
<li>多边形(分线段)拟合: Douglas-Peucker算法<br>对每一条离散曲线的起点终点虚连一条直线, 求所有点与直线的距离, 找出最大距离<script type="math/tex">d_{max}</script>, 与阈值<script type="math/tex">D</script>比较<ol>
<li><script type="math/tex">d_{max} < D</script>, 舍去这段曲线所有中间点(替换为这个线段)</li>
<li><script type="math/tex">d_{max} \geq D</script>, 保留<script type="math/tex">d_{max}</script>对应点, 以该点为界将曲线分成两部分, 然后对这两部分递归下去做</li>
</ol>
</li>
<li><p>Hough变换<br>解决的问题: 形状检测<br>基于投票原理的参数估计方法: 图像中每一点对参数组合进行表决, 赢得多数票的参数组合为胜者(结果).</p>
<ul>
<li>直线检测, 把直线用参数方程 <script type="math/tex">\rho=x\cos\theta+y\sin\theta</script>表示, 然后对离散化的<script type="math/tex">(\rho, \theta)</script>参数组合进行投票</li>
<li>更具体的步骤:<ol>
<li>适当量化参数空间(精度合适即可)</li>
<li>假定参数空间的每一个单元都是一个累加器，把累加器初始化为零．</li>
<li>对图像空间的每一点，在其所满足的参数方程对应的累加器上加1．</li>
<li>累加器阵列的最大值对应模型的参数．</li>
</ol>
</li>
<li><p>圆弧检测:有三个参数, 两个确定圆心, 一个给出半径<script type="math/tex">x=a+r\cos\theta,\ y=b+r\sin\theta</script> (<script type="math/tex">\theta</script>取边缘点梯度角) <script type="math/tex">\Rightarrow b=a\tan\theta-x\tan\theta+y</script> (关于<script type="math/tex">a,b</script>的参数空间)</p>
<ol>
<li>量化关于<script type="math/tex">a,b</script>的参数空间到合适精度</li>
<li>初始化所有累加器为0</li>
<li>计算图像空间中边缘点的梯度幅度<script type="math/tex">G_{mag}(x,y)</script>和角度<script type="math/tex">\theta(x,y)</script></li>
<li>若边缘点参数坐标满足<script type="math/tex">b=a\tan\theta-x\tan\theta+y</script>将对应累加器+1</li>
<li>最大值对应累加所在坐标即为图像空间中的圆心位置</li>
<li>得到圆心即可反过来求得半径<script type="math/tex">r</script></li>
</ol>
</li>
</ul>
</li>
</ul>
<h1 id="局部特征检测"><a href="#局部特征检测" class="headerlink" title="局部特征检测"></a>局部特征检测</h1><ul>
<li>Harris角点检测<ul>
<li>基本思想<br>通过观察一个小窗口应当可以很容易发现角点; 而朝着任何方向移动这个窗口都应该对图像的强度有很大的改变.下面这张图给出了预期的强度变化:<br><img src="Clipboard_2020-01-12-23-07-06.png" alt=""></li>
<li>窗口移动<script type="math/tex">[u,v]</script>时的强度变化公式:<br><img src="Clipboard_2020-01-12-23-11-53.png" alt=""></li>
<li>如果<script type="math/tex">u,v</script>很小，可以有近似<script type="math/tex">I(x+u, y+v)\approx I(x,y) + uI_x(x,)+vI_v(x,y)</script><br>所以得到了一个bilinear的近似(推导要记！):<script type="math/tex; mode=display">E(u,v)=\sum_{x,y}w(x,y)[I(x+u,y+v)-I(x,y)]^2\\=\sum_{x,y}w(x,y)[I(x,y)+uI_x(x,y)+vI_y(x,y)-I(x,y)]^2\\=\sum_{x,y}w(x,y)[uI_x(x,y)-vI_y(x,y)]^2\\=[u,v]
\left(\sum_{x,y}w(x,y)\left[\begin{matrix}
I_x^2 & I_xI_y \\
I_xI_y & I_y^2
\end{matrix}\right]\right)
\left[\begin{matrix}
u \\
v
\end{matrix}\right]\\=\left[u,v\right]
M
\left[\begin{matrix}
u \\
v
\end{matrix}\right]</script></li>
<li><strong>奇异值分析</strong><ul>
<li>对于<script type="math/tex">M</script>的奇异值<script type="math/tex">\lambda_1,\lambda_2</script>, <script type="math/tex">\lambda_{max}</script>对应变化最快的方向(<script type="math/tex">\lambda_{max}^{-1/2}</script>), <script type="math/tex">\lambda_{min}</script>对应变化最慢的方向(<script type="math/tex">\lambda_{min}^{-1/2}</script>)</li>
<li>衡量角点响应<script type="math/tex">R=\det M-k(\text{trace }M)^2,\ \det M=\lambda_1\lambda_2,\ \text{trace }M=\lambda_1+\lambda_2</script><ol>
<li><script type="math/tex">R>0且R较大</script>, 角点</li>
<li><script type="math/tex">R<0且R较小</script>, 边</li>
<li><script type="math/tex">|R|较小</script>, flat region</li>
</ol>
</li>
</ul>
</li>
<li>旋转不变性: 旋转后形状不变, 所以角点响应应该对旋转不变</li>
<li>灰度仿射部分不变性: 使用导数所以对<script type="math/tex">I\rightarrow I+b</script>不变; 但是对于<script type="math/tex">I\rightarrow aI</script>不具有不变性(对threshold的影响))</li>
<li>不具有尺度不变性</li>
</ul>
</li>
<li><strong>解决scale invariant detection</strong><ul>
<li>设计一个关于区域(圆)的”scale invariant”函数, 对于图中的一个点来说, 可以认为他是区域大小(圆半径)的一个函数<script type="math/tex">f(S)</script></li>
<li>常见手段: 取函数的局部最大值<ul>
<li>达到最大值的<script type="math/tex">S</script>应该是对于图像尺寸来说不变的, 通过找这个<script type="math/tex">S</script>在- 不同尺度下的关系可以找到最合适的区域大小</li>
<li>scale invariant的区域大小应该在各张图片里面单独找<br><img src="Clipboard_2020-01-13-00-31-02.png" alt=""></li>
</ul>
</li>
</ul>
</li>
<li>SIFT描述子的计算<ul>
<li>Full version计算的基本步骤:<ul>
<li>将16x16的窗口分成4x4格</li>
<li>对于每一格, 统计里面每一小格的梯度和方向(使用边的方向,即梯度方向-90度)直方图</li>
<li>threshold掉梯度小的方向</li>
<li>16格*8格方向, 128维的描述子</li>
</ul>
</li>
<li>利用梯度的意义<ul>
<li>梯度小的弱边可以threshold掉</li>
<li>利用patch里的dominant梯度对其进行定向, 这样就可以做到旋转不变性</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="人脸识别"><a href="#人脸识别" class="headerlink" title="人脸识别"></a>人脸识别</h1><ul>
<li>PCA主元分析<ul>
<li>基本思想: 通过线性变换为数据集选择一个新的坐标系:<ul>
<li>选择方差最大的投影方向作为第一条坐标轴</li>
<li>第二大的作为第二条, …</li>
</ul>
</li>
<li>用途: 通过降维方式简化数据集</li>
<li>什么样的数据适合用PCA?<br>多元高斯分布; 维度过高但高维信息量低，相关度高的数据</li>
<li>PCA求解<ul>
<li>输入向量<script type="math/tex">x</script>, 投影方向<script type="math/tex; mode=display">\begin{aligned}
var(z_1) &= E(z_1^2)-[E(z_1)]^2=E[(\sum_{i=1}^da_1^ix_i)^2]-[E(\sum_{i=1}^da_1^ix_i)]^2\\
&= \sum_{i,j=1}^da_1^ia_1^j[E(x_ix_j)-E(x_i)E(x_j)]\\
&= \sum_{i,j=1}^da_1^ia_1^jS_{ij}\\
&= a_1^TSa_1
\end{aligned}</script><script type="math/tex; mode=display">设\lambda为拉格朗日乘子, \because a_1^Ta_1=1 \\转化为求最大化a_1^TSa_1-\lambda(a_1^Ta_1-1)\\求微分, 得: Sa_1-\lambda a_1\Rightarrow Sa_1 = \lambda a_1\\a_k为k^{th}大的特征值对应的特征向量\\\Rightarrow \mathrm{var}(z_1)=a_1^T\lambda a_1=\lambda a_1^Ta_1=\lambda</script></li>
</ul>
</li>
</ul>
</li>
<li>Eigenface特征脸<ul>
<li>步骤<ol>
<li>获得人脸图像的训练集，通常为整个人脸数据库；</li>
<li>对所有人脸图像作归一化处理；<ul>
<li>尺寸归一化: mask</li>
<li>灰度归一化: 直方图均衡</li>
</ul>
</li>
<li>通过PCA计算获得一组特征向量(特征脸)。通常一百个特征向量就足够；</li>
<li>将每幅人脸图像都投影到由该组特征脸张成的子空间中，得到在该子空间坐标；</li>
<li>对输入的一幅待测图像，归一化后，将其映射到特征脸子空间中。然后用某种距离度量来描述两幅人脸图像的相似性，如欧氏距离。</li>
</ol>
</li>
<li>训练过程:<ul>
<li>求协方差矩阵<script type="math/tex">\Sigma=\frac{1}{K}\sum_{i=1}^K(x_i-\mu)(x_i-\mu)^T,\ \mu=\frac{1}{K}\sum_{i=1}^Kx_i</script></li>
<li>求<script type="math/tex">\Sigma</script>特征值与相应的归一特征向量</li>
<li>构建转换矩阵<script type="math/tex">y_i=A^Tx_i, \ A=[v_1, v_2, ..., v_k](选择前k个特征值)</script></li>
</ul>
</li>
<li>识别<script type="math/tex">y_f=A^Tf</script>, 重构<script type="math/tex">\hat f=Ay_f</script></li>
</ul>
</li>
<li>Fisherface*</li>
</ul>
<h1 id="图像频谱与图像分解"><a href="#图像频谱与图像分解" class="headerlink" title="图像频谱与图像分解"></a>图像频谱与图像分解</h1><ul>
<li>图像的傅里叶变换<ul>
<li>二维离散傅里叶变换<br>任何信号都可以表示成（或者无限逼近）一系列正弦信号的叠加。在一维领域，信号是一维正弦波的叠加，那么想象一下，在二维领域，实际上是无数二维平面波的叠加，<script type="math/tex">(x,y)</script>对应的是一维领域的 <script type="math/tex">t</script>，而灰度（Brightness Variation）就是其变量对应一维领域的振幅<script type="math/tex">F(t)</script>。傅里叶变换存储每一个频率的幅值和相位信息, 前者代表这个频率上由多少信号, 后者间接代表空间信息<script type="math/tex; mode=display">F(u,v) = \sum_{x=0}^{M-1}\sum_{y=0}^{N-1}f(x,y)e^{-i2\pi(uv/M+vy/N)}</script></li>
<li>高频分量: 途中灰度变化剧烈的部分(图像边缘、线条以及纹理等细节信息); 低频分量: 途中灰度变换平缓的部分(图像的轮廓信息)</li>
</ul>
</li>
<li>图像分解<br>图像分解就是把原始图像分解成两部分，结构和纹理。<ul>
<li>图像分解的角度理解傅里叶变换的意义<br>高频分量对应细节, 低频分量对应轮廓(?).<br>Gang Pan的课里讲这个的时候引入了基图像的概念, 我其实不太懂<br><img src="Clipboard_2020-01-13-16-08-33.png" alt=""></li>
<li>拉普拉斯图像金字塔<br><img src="Clipboard_2020-01-13-09-46-29.png" alt=""><ul>
<li>高斯金字塔用的低通滤波器(低频通过)</li>
<li>因为拉普拉斯是由高斯低通滤波器相邻两层内插放大后求差得到, 此过程相当于带通滤波(一个频带内的可以通过).</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="图像拼接"><a href="#图像拼接" class="headerlink" title="图像拼接"></a>图像拼接</h1><ul>
<li>RANSAC (RANdom SAmple Consensus)<ul>
<li>作用: 是大范围模型匹配问题的一个普遍意义上的方法，且运用简单，计算快。</li>
<li>基本思想<ul>
<li>为了避免异常值outlier的影响, 寻找正常值inlier并只使用它们</li>
<li>如果选择了一个异常来计算拟合, 拟合的结果线不会得到太多其他点的支持</li>
</ul>
</li>
<li>RANSAC步骤<ol>
<li>随机选择一组种子点来做基本的变换检测</li>
<li>从这组种子中计算变换</li>
<li>找出对于该变换是正常值的点</li>
<li>如果正常值很多, 对所有正常值重新计算变换的最小二乘估计</li>
<li>保留正常值最多的一个变换作为结果</li>
</ol>
</li>
</ul>
</li>
<li>work flow<ol>
<li>检测关键点</li>
<li>构造SIFT描述子</li>
<li>匹配SIFT描述子</li>
<li>拟合变换</li>
<li>RANSAC</li>
<li>拼接图像</li>
</ol>
</li>
</ul>
<h1 id="相机模型"><a href="#相机模型" class="headerlink" title="相机模型"></a>相机模型</h1><ul>
<li>基本概念<ul>
<li>光圈aperture: 可以看作小孔成像中的孔径, 光圈越大进光面积越大</li>
<li>景深depth of field: 相机镜头能够取得清晰图像的成像所测定的被摄物体前后范围距离<ul>
<li>光圈越小, 景深越大, 光圈太小会发生衍射现象也会糊; </li>
<li>焦距越短, 景深越大</li>
<li>拍摄距离越远, 景深越大</li>
</ul>
</li>
<li>焦距: 透镜光心与焦点距离</li>
<li>视场(角)field of view: 焦距越大视场角越小</li>
</ul>
</li>
<li>坐标系<ul>
<li>世界坐标系: 物体在真实世界中的坐标<script type="math/tex">O^w-x^w-y^w</script></li>
<li>相机坐标系: 相机光心<script type="math/tex">O</script>, 相机坐标系<script type="math/tex">O-x-y-z</script></li>
<li>图像坐标系: <script type="math/tex">O</script>在像平面投影<script type="math/tex">O'</script>即图像平面中心为缘点的坐标系<script type="math/tex">O'-x'-y'</script></li>
<li>像素坐标系: 以图像左上角像素为原点的<script type="math/tex">O-u-v</script></li>
</ul>
</li>
<li>坐标转换:<ul>
<li>世界坐标系 -&gt; 相机坐标系<script type="math/tex; mode=display">
\left[\begin{matrix}
x \\ y \\ z \\ 1
\end{matrix}\right]
=
\left[\begin{matrix}
R & t \\ 0^T & 1
\end{matrix}\right]
\left[\begin{matrix}
x^w \\ y^w \\ z^w \\ 1
\end{matrix}\right]</script><ul>
<li><script type="math/tex; mode=display">R, t$$中有六个自由度, 称为**相机外参(Extrinsic)**
- $$R=R_z(\theta), R_y(\phi), R_x(\psi)</script><script type="math/tex; mode=display">
R_x(\psi)=\left[\begin{matrix}
1 & 0 & 0 \\
0 & \cos\psi & \sin\psi \\
0 & -\sin\psi & \cos\psi
\end{matrix}\right]\ 
R_y(\phi)=\left[\begin{matrix}
\cos\phi & 0 & -\sin\phi \\
0 & 1 & 0 \\
\sin\phi & 0 & \cos\phi
\end{matrix}\right]\ 
R_z(\theta)=\left[\begin{matrix}
\cos\theta & \sin\theta & 0\\
-\sin\theta & \cos\theta & 0\\
0 & 0 & 1 
\end{matrix}\right]</script><ul>
<li><script type="math/tex; mode=display">t_{3\times 1}=(t_x, t_y, t_z)'</script></li>
</ul>
</li>
</ul>
</li>
<li>相机坐标系 -&gt; 像素坐标系<script type="math/tex; mode=display">
w\left[\begin{matrix}
u \\ v \\ 1
\end{matrix}\right]
=
\left[\begin{matrix}
f_x & 0 & c_x & 0 \\ 0 & f_y & c_y & 0 \\ 0 & 0 & 1 & 0
\end{matrix}\right]
\left[\begin{matrix}
x \\ y \\ z \\ 1
\end{matrix}\right]</script><ul>
<li><strong>内参矩阵</strong><script type="math/tex; mode=display">M=\left[\begin{matrix}
f_x & 0 & c_x & 0 \\ 0 & f_y & c_y & 0 \\ 0 & 0 & 1 & 0
\end{matrix}\right]</script><ul>
<li><script type="math/tex; mode=display">f_x=Fs_x, f_y=Fs_y</script></li>
<li><script type="math/tex">F</script>: mm 焦距</li>
<li><script type="math/tex">s_x, s_y</script>: pixel/mm</li>
<li><script type="math/tex">f_x, f_y</script>: pixel</li>
</ul>
</li>
</ul>
</li>
<li>畸变</li>
</ul>
</li>
<li>径向畸变: 透镜形状导致的畸变<script type="math/tex; mode=display">
x_{corrected}=x(1+k_1r^2+k_2r^4+k_3r^6)\\
y_{corrected}=y(1+k_1r^2+k_2r^4+k_3r^6)\\</script></li>
<li>切向畸变: 透镜与成像平面不平行导致的畸变<script type="math/tex; mode=display">
x_{corrected}=x+2p_1xy+p_2(r^2+2x^2)\\
y_{corrected}=y+2p_2xy+p_1(r^2+2y^2)</script></li>
<li>畸变系数<script type="math/tex">(k_1, k_2, p_1, p_2, k_3)</script></li>
</ul>
<ul>
<li>相机标定<ul>
<li>任务: 获取相机参数: 内参, 外参, 畸变系数</li>
<li>基本思想<script type="math/tex">p_{dst}=Hp_{src},\ p_{src}=H^{-1}p_{dst}</script></li>
<li>自标定<ul>
<li>不需要标定物体</li>
<li>在静态场景内移动相机</li>
<li>场景的刚性限制相机内参; 对应的b/w图像足够恢复内参外参</li>
<li>灵活但不够可靠</li>
</ul>
</li>
<li>基于3d参考物体标定<ul>
<li>观察3d空间中一个已知几何形状的物体, 物体一般需要两到三个正交平面</li>
</ul>
</li>
<li>基于平面的标定(homography-based)<ul>
<li>观察一个平面calibration pattern图像, 至少需要2种不同的观察方向(两张图)</li>
<li>优点: 比前面两者更灵活鲁棒<ul>
<li>易于安装</li>
<li>每个人都能制作这个平面图像</li>
</ul>
</li>
<li>棋盘标定的基本过程:<ul>
<li>确定标定目标: 与棋盘成直角的两个平面</li>
<li>构造格点对该目标的坐标系统</li>
<li>获得图像的格点</li>
<li>使用图像坐标到世界坐标的方程得到相机内参外参(畸变系数)</li>
</ul>
</li>
<li>一副图像的自由度: 8, 求解最少需要4个点, 8个等式</li>
<li>需要的图像数量<ul>
<li>假设<script type="math/tex">N</script>格点, <script type="math/tex">K</script>个图像, 有<script type="math/tex">2NK</script>个格点限制</li>
<li><script type="math/tex; mode=display">2NK \geq 6K+4</script></li>
<li>如果<script type="math/tex">K=2</script>, <script type="math/tex">N=4</script></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="双目视觉"><a href="#双目视觉" class="headerlink" title="双目视觉"></a>双目视觉</h1><ul>
<li>四个步骤<ol>
<li>Undistortion: 消除畸变得到无畸变图像</li>
<li>Rectification: 校正相机使得两个图像行对齐<ul>
<li>意义: 把2D搜索变成1D搜索, 才能算出视差</li>
</ul>
</li>
<li>Correspondence(Stereo matching): 在两个图像中找到相同的特征得到视差<ul>
<li>可以用SIFT做</li>
</ul>
</li>
<li>Reprojection: 重投影从三角剖分得到深度图<ul>
<li>深度与视差反相关; 与焦距, 眼距正相关</li>
</ul>
</li>
</ol>
</li>
<li>三角化<br><img src="Clipboard_2020-01-13-13-08-34.png" alt=""></li>
</ul>
<h1 id="结构光"><a href="#结构光" class="headerlink" title="结构光"></a>结构光</h1><ul>
<li>系统构成: 结构光投影仪, CCD相机, 扫描对象<br><img src="Clipboard_2020-01-13-13-18-17.png" alt=""></li>
<li><script type="math/tex; mode=display">[x, y, z]=\frac{b}{f\cot\theta-x'}[x', y', f]</script><ul>
<li>推导<script type="math/tex; mode=display">\tan\theta=\frac{z}{b+x}\\\frac{x}{x'}=\frac{(b+x)\tan\theta}{f}\\x=\frac{b}{f\cot\theta-x'}</script></li>
</ul>
</li>
<li>基于光条的位码<ul>
<li>逐个点扫描太慢, 将光分为光条来加速扫描过程</li>
<li>位码含义<ul>
<li>位码为<script type="math/tex">x</script>,使用二进制下第<script type="math/tex">x</script>为1的光条, 如位码为1时为1,3,5,7</li>
</ul>
</li>
</ul>
</li>
<li>ICP(Iterative Closest Point 迭代最近点法)<ul>
<li>问题: 如何把多个扫描结果拼接在一起</li>
<li>基本步骤<ol>
<li>首先建立两个扫描结果之间点对应关系, 根据最近原则初始化一个<script type="math/tex">R, t</script></li>
<li>通过迭代获得一个仿射变换来描述1.中对应点的变换关系(平均距离最小)</li>
<li>对扫描结果上所有点应用该仿射变换函数</li>
<li>选取两个扫描结果中距离最近的点作为对应点, 计算对应点距离, 若大于阈值则继续2.3., 否则结束</li>
</ol>
</li>
</ul>
</li>
<li>Shape from shading<ul>
<li>三个假设: Lambertian表面(理想散射平面), 较远点光源, 较远观察者<script type="math/tex; mode=display">
\begin{aligned}
I_D &= \mathbf{L}\cdot\mathbf{N}*C*I_L \\
&= C * I_L * |\mathbf{N}| |\mathbf{L}| \cos\alpha
\end{aligned}</script></li>
</ul>
</li>
</ul>
<h1 id="光流法"><a href="#光流法" class="headerlink" title="光流法"></a>光流法</h1><ul>
<li>问题: 如何从图像<script type="math/tex">H</script>与图像<script type="math/tex">I</script>中检测像素的移动?<ul>
<li>解决像素匹配问题, 给定<script type="math/tex">H</script>像素, 寻找<script type="math/tex">I</script>中附近相同颜色的像素</li>
</ul>
</li>
<li>三个关键假设:<ul>
<li>亮度恒定</li>
<li>空间连贯性<ul>
<li>场景中属于相同物体的邻点应该有相似的动作</li>
</ul>
</li>
<li>移动幅度较小<script type="math/tex; mode=display">
\begin{aligned}
0 &= I(x+u, y+v) - H(x, y)\\
&\approx I(x,y)+I_xu+I_yv-H(x,y)\\
&\approx (I(x,y)-H(x,y))+I_xu+ I_yv\\
&\approx I_t+I_xu+I_yv\\
&\approx I_t+\nabla I\cdot[u\ v]
\end{aligned}</script></li>
</ul>
</li>
<li>使用纹理复杂区域的光流比较可靠, 因为梯度大且方向不同, 求出来特征值比较大; 避免使用边缘上的点计算光流</li>
<li>为了克服三个假设可能不满足的困难, 可以分为更小的步骤一轮轮迭代</li>
<li>Coarse-to-fine的克服方法<ul>
<li>在高斯金字塔上做, 自顶向下</li>
<li>每一层跑一次LK算法, warp之后上采样, 重复该步骤</li>
</ul>
</li>
</ul>
<h1 id="图像分割"><a href="#图像分割" class="headerlink" title="图像分割"></a>图像分割</h1><ul>
<li><p>K-means算法</p>
<ul>
<li><p>目标: <script type="math/tex">c^*, \delta^*=\mathrm{argmin}_{c, \delta}\frac{1}{N}\sum_j^N\sum_i^K\delta_{i,j}(c_i-x_j)^2</script></p>
<ul>
<li><script type="math/tex">c</script>中心点, <script type="math/tex">\delta</script>聚类, <script type="math/tex">x</script>数据</li>
</ul>
</li>
<li>步骤<ol>
<li>随机选取K个中心点<script type="math/tex; mode=display">c^0;\ t=0</script></li>
<li>将每个点分配到最近的中心点(聚类)<script type="math/tex; mode=display">\delta^t=\mathrm{argmin}_{\delta}\frac{1}{N}\sum_j^N\sum_i^K\delta_{ij}(c_i^{t-1}-x_j)^2</script></li>
<li>算出每个聚类中的中心, 继续迭代2.3.<script type="math/tex; mode=display">c^t=\mathrm{argmin}_{\delta}\frac{1}{N}\sum_j^N\sum_i^K\delta_{ij}^t(c_i-x_j)^2</script></li>
</ol>
</li>
<li>Mean shift<br>对每一个点集寻找一个mode<ol>
<li>选择kernel和bandwidth</li>
<li>对每个点<ol>
<li>找一个该点的窗口</li>
<li>计算窗口内数据平均值</li>
<li>将窗口中心设为新的平均值的位置</li>
<li>重复上面两步直到收敛</li>
</ol>
</li>
<li>将mode附近的点分配给同一个聚类</li>
</ol>
<ul>
<li>优点<ul>
<li>泛用性较好</li>
<li>区域的数量和形状灵活</li>
<li>对异常值鲁棒</li>
</ul>
</li>
<li>缺点<ul>
<li>难以选择kernel size</li>
<li>不适合高维特征</li>
</ul>
</li>
</ul>
</li>
<li>基于Graph Cut的图像分割<ul>
<li>将每个像素当作一个点, 边表示像素间的关系, 边权表示每对邻点的相似度(其实应该是距离?)</li>
<li>Ford-Fulkerson算法求最大割</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="物体检测与识别"><a href="#物体检测与识别" class="headerlink" title="物体检测与识别"></a>物体检测与识别</h1><ul>
<li>积分图<ul>
<li>积分图感觉有点像一个矩阵二维前缀和</li>
<li>因为初期提取的特征很多, 需要进行特征选取, 训练一个弱分类器来找出一个矩形特征来最好地区分正样本负样本</li>
<li></li>
</ul>
</li>
<li>词袋(BoW bag-of-words)模型<ul>
<li>词袋概念: <ul>
<li>一系列单独的feature</li>
<li>使用直方图来表示</li>
</ul>
</li>
<li>基本步骤:<ul>
<li>特征抽取与表示</li>
<li>从训练样本中使用聚类构建codebook(codeword字典)</li>
<li>用codebook的直方图来表示(例如BoW)</li>
<li>使用BoW来对未知图象进行分类</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="深度学习"><a href="#深度学习" class="headerlink" title="深度学习"></a>深度学习</h1><ul>
<li>端到端学习: 只关心输入输出, 把多阶段任务放在一个步骤里解决</li>
<li>本质是学习权重, 常用梯度下降法</li>
<li>卷积层<ul>
<li>作用: 用于提取图像特征</li>
<li>参数个数只与kernel数量与size有关, 卷积层输出size的计算(原图size, 步长stride, kernel size)</li>
</ul>
</li>
<li>pooling层 <ul>
<li>作用: 用于简化特征表达, 减少特征数量</li>
<li>max pooling, mean pooling </li>
<li>默认步长与size相同相当于缩放</li>
</ul>
</li>
<li>LeNet<br><img src="Clipboard_2020-01-13-15-13-03.png" alt=""><ul>
<li>S2, C3层连接方式<br><img src="Clipboard_2020-01-13-15-18-43.png" alt=""></li>
</ul>
</li>
<li>TensorFlow: tf.placeholder, tf.Variable, tf.nn.conv2d, tf.nn.bias_add, tf.nn.relu</li>
</ul>

    </article>
    <!-- license  -->
    
        <div class="license-wrapper">
            <p>Author：<a href="http://huangyangyi.github.io">Huang Yangyi</a>
            <p>原文链接：<a href="http://huangyangyi.github.io/2020/01/13/cvnote/">http://huangyangyi.github.io/2020/01/13/cvnote/</a>
            <p>发表日期：<a href="http://huangyangyi.github.io/2020/01/13/cvnote/">January 13th 2020, 10:13:50 am</a>
            <p>更新日期：<a href="http://huangyangyi.github.io/2020/01/13/cvnote/">January 22nd 2020, 3:24:36 pm</a>
            <p>版权声明：本文采用<a rel="license noopener" href="http://creativecommons.org/licenses/by-nc/4.0/" target="_blank">知识共享署名-非商业性使用 4.0 国际许可协议</a>进行许可</p>
        </div>
    
    <!-- paginator  -->
    <ul class="post-paginator">
        <li class="next">
            
                <div class="nextSlogan">Next Post</div>
                <a href= "/2020/01/21/cdq-thesis/" title= "NEURAL READING COMPREHENSION AND BEYOND 论文笔记【待填】">
                    <div class="nextTitle">NEURAL READING COMPREHENSION AND BEYOND 论文笔记【待填】</div>
                </a>
            
        </li>
        <li class="previous">
            
        </li>
    </ul>
    <!-- 评论插件 -->
    <!-- 来必力City版安装代码 -->

    <div id="lv-container" data-id="city" data-uid= MTAyMC80OTUwNS8yNTk5Ng==>
        <script type="text/javascript">
            (function (d, s) {
                var j, e = d.getElementsByTagName(s)[0];
                if (typeof LivereTower === 'function') { return; }
                j = d.createElement(s);
                j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
                j.async = true;

                e.parentNode.insertBefore(j, e);
            })(document, 'script');
        </script>
        <noscript>为正常使用来必力评论功能请激活JavaScript</noscript>
    </div>

<!-- City版安装代码已完成 -->
    
    
    <!-- partial('_partial/comment/changyan') -->
    <!--PC版-->


    
    

    <!-- 评论 -->
</main>
            <!-- profile -->
            
        </div>
        <footer class="footer footer-unloaded">
    <!-- social  -->
    
    <div class="social">
        
    
        
            
                <a href="mailto:HuangYangyi@zju.edu.cn" class="iconfont-archer email" title=email ></a>
            
        
    
        
            
                <a href="//github.com/huangyangyi" class="iconfont-archer github" target="_blank" title=github></a>
            
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    

    </div>
    
    <!-- powered by Hexo  -->
    <div class="copyright">
        <span id="hexo-power">Powered by <a href="https://hexo.io/" target="_blank">Hexo</a></span><span class="iconfont-archer power">&#xe635;</span><span id="theme-info">theme <a href="https://github.com/fi3ework/hexo-theme-archer" target="_blank">Archer</a></span>
    </div>
    <!-- 不蒜子  -->
    
    <div class="busuanzi-container">
    
     
    <span id="busuanzi_container_site_pv">PV: <span id="busuanzi_value_site_pv"></span> :)</span>
    
    </div>
    
</footer>
    </div>
    <!-- toc -->
    
    <div class="toc-wrapper" style=
    







top:50vh;

    >
        <div class="toc-catalog">
            <span class="iconfont-archer catalog-icon">&#xe613;</span><span>CATALOG</span>
        </div>
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#计算机视觉要解决的任务"><span class="toc-number">1.</span> <span class="toc-text">计算机视觉要解决的任务</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Marr视觉计算理论"><span class="toc-number">2.</span> <span class="toc-text">Marr视觉计算理论</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#格式塔心理学"><span class="toc-number">3.</span> <span class="toc-text">格式塔心理学</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#二值图像"><span class="toc-number">4.</span> <span class="toc-text">二值图像</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#边缘检测"><span class="toc-number">5.</span> <span class="toc-text">边缘检测</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#曲线"><span class="toc-number">6.</span> <span class="toc-text">曲线</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#局部特征检测"><span class="toc-number">7.</span> <span class="toc-text">局部特征检测</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#人脸识别"><span class="toc-number">8.</span> <span class="toc-text">人脸识别</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#图像频谱与图像分解"><span class="toc-number">9.</span> <span class="toc-text">图像频谱与图像分解</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#图像拼接"><span class="toc-number">10.</span> <span class="toc-text">图像拼接</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#相机模型"><span class="toc-number">11.</span> <span class="toc-text">相机模型</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#双目视觉"><span class="toc-number">12.</span> <span class="toc-text">双目视觉</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#结构光"><span class="toc-number">13.</span> <span class="toc-text">结构光</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#光流法"><span class="toc-number">14.</span> <span class="toc-text">光流法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#图像分割"><span class="toc-number">15.</span> <span class="toc-text">图像分割</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#物体检测与识别"><span class="toc-number">16.</span> <span class="toc-text">物体检测与识别</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#深度学习"><span class="toc-number">17.</span> <span class="toc-text">深度学习</span></a></li></ol>
    </div>
    
    <div class="back-top iconfont-archer">&#xe639;</div>
    <div class="sidebar sidebar-hide">
    <ul class="sidebar-tabs sidebar-tabs-active-0">
        <li class="sidebar-tab-archives"><span class="iconfont-archer">&#xe67d;</span><span class="tab-name">Archive</span></li>
        <li class="sidebar-tab-tags"><span class="iconfont-archer">&#xe61b;</span><span class="tab-name">Tag</span></li>
        <li class="sidebar-tab-categories"><span class="iconfont-archer">&#xe666;</span><span class="tab-name">Cate</span></li>
    </ul>
    <div class="sidebar-content sidebar-content-show-archive">
          <div class="sidebar-panel-archives">
    <!-- 在ejs中将archive按照时间排序 -->
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    <div class="total-and-search">
        <div class="total-archive">
        Total : 5
        </div>
        <!-- search  -->
        
    </div>
    
    <div class="post-archive">
    
    
    
    
    <div class="archive-year"> 2020 </div>
    <ul class="year-list">
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">04/05</span><a class="archive-post-title" href= "/2020/04/05/nms/" >Bounding Box Regression with Uncertainty for Accurate Object Detection</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">03/11</span><a class="archive-post-title" href= "/2020/03/11/compiler/" >Lecture Notes -- Compile Principle and Technology (Updating)</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">02/25</span><a class="archive-post-title" href= "/2020/02/25/mono3D/" >单目3D目标检测论文笔记</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">01/21</span><a class="archive-post-title" href= "/2020/01/21/cdq-thesis/" >NEURAL READING COMPREHENSION AND BEYOND 论文笔记【待填】</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">01/13</span><a class="archive-post-title" href= "/2020/01/13/cvnote/" >计算机视觉 期末速成笔记</a>
        </li>
    
    </div>
  </div>
        <div class="sidebar-panel-tags">
    <div class="sidebar-tags-name">
    
        <span class="sidebar-tag-name" data-tags="编译原理"><span class="iconfont-archer">&#xe606;</span>编译原理</span>
    
        <span class="sidebar-tag-name" data-tags="Computer Vision"><span class="iconfont-archer">&#xe606;</span>Computer Vision</span>
    
        <span class="sidebar-tag-name" data-tags="Natural Language Processing"><span class="iconfont-archer">&#xe606;</span>Natural Language Processing</span>
    
        <span class="sidebar-tag-name" data-tags="Deep Learning"><span class="iconfont-archer">&#xe606;</span>Deep Learning</span>
    
    </div>
    <div class="iconfont-archer sidebar-tags-empty">&#xe678;</div>
    <div class="tag-load-fail" style="display: none; color: #ccc; font-size: 0.6rem;">
    缺失模块。<br/>
    1、请确保node版本大于6.2<br/>
    2、在博客根目录（注意不是archer根目录）执行以下命令：<br/>
    <span style="color: #f75357; font-size: 1rem; line-height: 2rem;">npm i hexo-generator-json-content --save</span><br/>
    3、在根目录_config.yml里添加配置：
    <pre style="color: #787878; font-size: 0.6rem;">
jsonContent:
  meta: false
  pages: false
  posts:
    title: true
    date: true
    path: true
    text: false
    raw: false
    content: false
    slug: false
    updated: false
    comments: false
    link: false
    permalink: false
    excerpt: false
    categories: true
    tags: true</pre>
    </div> 
    <div class="sidebar-tags-list"></div>
</div>
        <div class="sidebar-panel-categories">
    <div class="sidebar-categories-name">
    
        <span class="sidebar-category-name" data-categories="课程笔记"><span class="iconfont-archer">&#xe60a;</span>课程笔记</span>
    
        <span class="sidebar-category-name" data-categories="论文笔记"><span class="iconfont-archer">&#xe60a;</span>论文笔记</span>
    
    </div>
    <div class="iconfont-archer sidebar-categories-empty">&#xe678;</div>
    <div class="sidebar-categories-list"></div>
</div>
    </div>
</div> 
    <script>
    var siteMeta = {
        root: "/",
        author: "Huang Yangyi"
    }
</script>
    <!-- CDN failover -->
    <script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script>
    <script type="text/javascript">
        if (typeof window.$ === 'undefined')
        {
            console.warn('jquery load from jsdelivr failed, will load local script')
            document.write('<script src="/lib/jquery.min.js">\x3C/script>')
        }
    </script>
    <script src="/scripts/main.js"></script>
    <!-- algolia -->
    
    <!-- busuanzi  -->
    
    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    
    <!-- CNZZ  -->
    
    </div>
    <!-- async load share.js -->
    
        <script src="/scripts/share.js" async></script>    
     
    </body>
</html>


